import random
import math
from collections import defaultdict
# Карта еды, где 1 - еда, 0 - пустая ячейка
map_grid = [
[0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
[0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
[0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
[0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
[0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
[0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,1,0,0,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
];

rows = len(map_grid)
cols = len(map_grid[0])

# Начальные параметры для алгоритма отжига
initial_temperature = 1000
cooling_rate = 0.99
min_temperature = 1e-3


# Функция для вычисления тороидальных координат
def toroidal_position(x, y):
    return x % rows, y % cols


# Функция для проверки наличия еды в соседних ячейках, избегая посещенных
def check_for_food(x, y, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Право, Вниз, Лево, Вверх
    for dx, dy in directions:
        nx, ny = toroidal_position(x + dx, y + dy)
        if map_grid[nx][ny] == 1 and (nx, ny) not in visited:
            return (nx, ny)
    return None


# Функция для генерации соседнего состояния, избегая посещенных
def generate_neighbor(position, visited_count):
    x, y = position
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    random.shuffle(directions)  # Перемешиваем направления для случайного выбора

    # Находим клетку с минимальным количеством посещений
    min_visited = float('inf')
    best_move = position

    for dx, dy in directions:
        new_x, new_y = toroidal_position(x + dx, y + dy)
        if visited_count[(new_x, new_y)] < min_visited:
            min_visited = visited_count[(new_x, new_y)]
            best_move = (new_x, new_y)

    return best_move


# Функция симуляции с автоматом и отжигом
def ant_simulation():
    # Начальная позиция муравья (0,0)
    current_position = (0, 0)
    path = [current_position]
    visited_count = defaultdict(int)  # Счётчик посещений клеток
    visited_count[current_position] += 1  # Начальная клетка

    current_score = 0  # Счётчик собранной еды

    temperature = initial_temperature


    print("Начальная точка:", current_position)

    for i in range(100):
        # Проверка на наличие еды в соседних ячейках
        next_position = check_for_food(*current_position, visited_count)

        # Если еда найдена рядом, муравей движется туда
        if next_position:
            current_position = next_position
        else:
            # Иначе используется отжиг для выбора соседней клетки
            neighbor_position = generate_neighbor(current_position, visited_count)
            current_position = neighbor_position

        # Проверка на еду в текущей позиции
        x, y = current_position
        if map_grid[x][y] == 1:
            current_score += 1
            map_grid[x][y] = 0  # Убираем еду после её сбора

        # Обновление пути и счётчика посещений
        path.append(current_position)
        visited_count[current_position] += 1

        # Отображение текущего шага
        print(f"Шаг: {len(path)}, Позиция: {current_position}, Собрано еды: {current_score}")

        # Понижение температуры
        temperature *= cooling_rate

    print("\nКонечный путь муравья:")
    for step, (x, y) in enumerate(path):
        print(f"Шаг {step + 1}: Позиция ({x},{y})")

    return path, current_score


# Запуск алгоритма
best_path, best_score = ant_simulation()
print(f"\nМаксимум собранной еды: {best_score}")
